/*
 * MC3479.cpp
 *
 *  Created on: Oct 9, 2022
 *      Author: mmmta
 */
//TODO: Add try/except or assertion clauses to all methods
#include "../Inc/MC3479.h"


MC3479Class MC3479;

// Set the MC3479's I2C object and initialize the device I
bool MC3479Class::setSerialI2C(I2C_TypeDef * i2c, uint8_t devId)
{
	this->_I2C1 = i2c;
	this->I2C_DEVICE_ID = devId;
	this->I2C_writeId = (I2C_DEVICE_ID << 1) | 0x00;
	this->I2C_readId = (I2C_DEVICE_ID << 1) | 0x01;
	return 1; // Return Success
}

// Set the MC3479's SPI object
bool MC3479Class::setSerialSPI(SPI_HandleTypeDef * spi,GPIO_TypeDef csn_GPIO, uint16_t csn_PIN )
{
	this->_SPI1 = spi;
	this->_CSN_GPIO = csn_GPIO;
	this->_CSN_PIN = csn_PIN;
	return 1; // Return Success
}

// Read from a register using SPI
bool MC3479Class::SPI_readRegister(uint8_t reg,  uint8_t* data)
{

	uint8_t spiBytes[2];
	spiBytes[0] = SPIread_REG && reg;
	spiBytes[1] = SPIread_BYTE2;
	HAL_GPIO_WritePin(this->csn_GPIO, this->csn_PIN, GPIO_PIN_RESET);
	HAL_SPI_Transmit(_SPI1, spiBytes, sizeof(spiBytes), 10);
	HAL_SPI_Receive(_SPI1, data, REG_BYTES_LEN, 10);
	HAL_GPIO_WritePin(this->csn_GPIO, this->csn_PIN, GPIO_PIN_SET);
	return 1;
}

// Write to a register using SPI
uint8_t MC3479Class::SPI_writeRegister(uint8_t reg, uint8_t data)
{
	// Write data to reg:
	uint8_t spiBytes[2];
	spiBytes[0] = SPIwrite_REG && reg;
	spiBytes[1] = data;
	HAL_GPIO_WritePin(this->csn_GPIO, this->csn_PIN, GPIO_PIN_RESET);
	HAL_SPI_Transmit(_SPI1, spiBytes, sizeof(spiBytes), 10);
	HAL_GPIO_WritePin(this->csn_GPIO, this->csn_PIN, GPIO_PIN_SET);

	// Read back the register and return the bytes:
	uint8_t regReadBack = 0;
	MC3479.SPI_readRegister(reg, this->csn_GPIO, this->csn_PIN, &regReadBack);
	return regReadBack;
}

// Read from a register using SPI
bool burstSPI_readRegister(uint8_t reg, GPIO_TypeDef csn_GPIO, uint16_t csn_PIN, uint8_t* data)
{
	return 1;
}

// Write to a register using SPI
bool burstSPI_writeRegister(uint8_t reg, GPIO_TypeDef csn_GPIO, uint16_t csn_PIN, uint8_t data)
{
	return 1;
}

// Read from a register using I2C
uint8_t MC3479Class::I2C_readRegister(uint8_t reg, uint8_t* data)
{

	//HAL_I2C_Master_Transmit(_I2C1, I2C_DEVICE_ID, data, REG_BYTES_LEN, 10)
	return 1;
}

// Write to a register using I2C
uint8_t MC3479Class::I2C_writeRegister(uint8_t reg, uint8_t data)
{
	return 1;
}


// Perform the initial MC3479 hard-coded configuration
void MC3479Class::configAccelerometer(){
	if (&_SPI1 != NULL){
		//Config using SPI:
		MC3479Class::SPI_writeRegister(MC3479_INTR_CTRL, csn_GPIO, csn_PIN, data)
		// Register 0x06 (interrupt enable)

		// Register 0x07 (MODE)

		// Register 0x08 (Sample  Rate)

		// Register 0x09 (Motion Control)

		// Register 0x20 (Range Select Control)

		// Register 0x21 (X-offset lSB)

		// Register 0x22 (X-offset MSB)

		// Register 0x23 (Y-offset LSB)

		// Register 0x24 (Y-offset MSB)

		// Register 0x25 (Z-offset LSB)

		// Register 0x26 (Z-offset MSB)

		// Register 0x27 (X Gain)

		// Register 0x28 (Y Gain)

		// Register 0x29 (Z Gain)

		// RegisteO 0x2D (FIFO Control)

		// Register 0x2E (FIFO Threshold)

		// Register 0x2F (FIFO Interrupt Status)

		// Register 0x30 (FIFO Control 2, Sample Rate 2)

		// Register 0x31 (Comm. Control)

		// Register 0x33 (GPIO Control)

		// Register 0x40 (Tilt/Flip threshold LSB)

		// Register 0x41 (Tilt/Flip threshold MSB)

		// Register 0x42 (Tilt/Flip Debounce)

		// Register 0x43 (AnyMotion Threshold LSB)

		// Register 0x44 (AnyMotion Threshold MSB)

		// Register 0x45 (AnyMotion Debounce)

		// Register 0x46 (Shake Threshold LSB)

		// Register 0x47 (Shake Threshold MSB)

		// Register 0x48 (Peak-to-Peak Duration LSB)

		// Register 0x49 (Shake/Peak-to-Peak Duration MSB)

		// Register 0x4A (Timer control)

		// Register 0x4B (Read Count Register)



	}else{
		//Config using I2C:

		// Register 0x06 (interrupt enable)

		// Register 0x07 (MODE)

		// Register 0x08 (Sample  Rate)

		// Register 0x09 (Motion Control)

		// Register 0x20 (Range Select Control)

		// Register 0x21 (X-offset lSB)

		// Register 0x22 (X-offset MSB)

		// Register 0x23 (Y-offset LSB)

		// Register 0x24 (Y-offset MSB)

		// Register 0x25 (Z-offset LSB)

		// Register 0x26 (Z-offset MSB)

		// Register 0x27 (X Gain)

		// Register 0x28 (Y Gain)

		// Register 0x29 (Z Gain)

		// RegisteO 0x2D (FIFO Control)

		// Register 0x2E (FIFO Threshold)

		// Register 0x2F (FIFO Interrupt Status)

		// Register 0x30 (FIFO Control 2, Sample Rate 2)

		// Register 0x31 (Comm. Control)

		// Register 0x33 (GPIO Control)

		// Register 0x40 (Tilt/Flip threshold LSB)

		// Register 0x41 (Tilt/Flip threshold MSB)

		// Register 0x42 (Tilt/Flip Debounce)

		// Register 0x43 (AnyMotion Threshold LSB)

		// Register 0x44 (AnyMotion Threshold MSB)

		// Register 0x45 (AnyMotion Debounce)

		// Register 0x46 (Shake Threshold LSB)

		// Register 0x47 (Shake Threshold MSB)

		// Register 0x48 (Peak-to-Peak Duration LSB)

		// Register 0x49 (Shake/Peak-to-Peak Duration MSB)

		// Register 0x4A (Timer control)

		// Register 0x4B (Read Count Register)


	}
	return;
}



